<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>DIDLab - ERC-20 DApp</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    html, body {
      font-family: system-ui, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
      margin: 0;
      padding: 0;
      background: #0b1320;
      color: #e6eaf2;
    }
    .wrap {
      max-width: 880px;
      margin: 40px auto;
      padding: 24px;
      border: 1px solid #24314a;
      border-radius: 14px;
      background: #0f1a2b;
    }
    h1 {
      margin: 0 0 16px;
      font-size: 22px;
    }
    .row {
      display: flex;
      gap: 12px;
      flex-wrap: wrap;
      margin: 8px 0;
    }
    .row > * {
      flex: 1;
    }
    input, select, button {
      padding: 10px 12px;
      border: 1px solid #314164;
      background: #0b1527;
      color: #e6eaf2;
      border-radius: 10px;
    }
    button {
      cursor: pointer;
    }
    button.primary {
      background: #335cff;
      border-color: #335cff;
    }
    .mono {
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
    }
    .card {
      padding: 12px;
      border: 1px solid #24314a;
      border-radius: 10px;
      background: #0b1527;
    }
    .muted {
      opacity: 0.8;
    }
    .ok { color: #7be07b; }
    .warn { color: #ffd166; }
    .err { color: #ff6b6b; }
    a { color: #9bc1ff; }
    .kvs {
      display: grid;
      grid-template-columns: 180px 1fr;
      gap: 8px;
    }
    .kvs div {
      padding: 6px 8px;
      border-bottom: 1px dashed #22314e;
    }
  </style>
</head>
<body>
  <div class="wrap">
    <h1>DIDLab - ERC-20 DApp</h1>
    <!-- CONFIG -->
    <div class="card">
      <div class="row">
        <div>
          <label>Network</label>
          <select id="network">
            <option value="trust">DIDLab TrustNet (252501)</option>
          </select>
        </div>
        <div>
          <label>RPC Endpoint</label>
          <input id="rpc" class="mono" placeholder="https://eth.didlab.org" />
        </div>
      </div>
      <div class="row">
        <div>
          <label>Token Address</label>
          <input id="tokenAddr" class="mono" placeholder="Paste deployed token 0x..." />
        </div>
      </div>
      <div class="row">
        <button id="btnConnect" class="primary">1) Connect & Switch Network</button>
        <button id="btnLoad">2) Load Token</button>
        <button id="btnWatch">Add Token to MetaMask</button>
        <button id="btnRefresh">Refresh Balance</button>
      </div>
    </div>

    <!-- STATUS -->
    <div class="row">
      <div class="card">
        <div class="kvs">
          <div class="muted">Account</div>
          <div id="acct" class="mono">-</div>
          <div class="muted">Network</div>
          <div id="net" class="mono">-</div>
          <div class="muted">Token</div>
          <div id="meta" class="mono">-</div>
          <div class="muted">Balance</div>
          <div id="bal" class="mono">-</div>
        </div>
      </div>
    </div>

    <!-- TRANSFER -->
    <div class="card">
      <h3>Transfer</h3>
      <div class="row">
        <input id="to" class="mono" placeholder="Recipient 0x..." />
        <input id="amt" class="mono" placeholder="Amount (human units)" />
        <button id="btnSend" class="primary">Send</button>
      </div>
      <div id="txlog" class="mono muted"></div>
    </div>

    <p class="muted">Tip: values persist in localStorage.</p>
  </div>

  <script type="module">
    import {
      createPublicClient,
      createWalletClient,
      custom,
      getAddress,
      formatUnits,
      parseUnits
    } from "https://esm.sh/viem@2.37.5";

    const ERC20_ABI = [
      { type: "function", name: "name", stateMutability: "view", inputs: [], outputs: [{ type: "string" }] },
      { type: "function", name: "symbol", stateMutability: "view", inputs: [], outputs: [{ type: "string" }] },
      { type: "function", name: "decimals", stateMutability: "view", inputs: [], outputs: [{ type: "uint8" }] },
      { type: "function", name: "balanceOf", stateMutability: "view", inputs: [{ name: "account", type: "address" }], outputs: [{ type: "uint256" }] },
      { type: "function", name: "transfer", stateMutability: "nonpayable", inputs: [{ name: "to", type: "address" }, { name: "amount", type: "uint256" }], outputs: [{ type: "bool" }] },
      {
        type: "event",
        name: "Transfer",
        inputs: [
          { indexed: true, name: "from", type: "address" },
          { indexed: true, name: "to", type: "address" },
          { indexed: false, name: "value", type: "uint256" }
        ]
      }
    ];

    const NETWORKS = {
      trust: {
        id: 252501,
        name: "DIDLab TrustNet",
        rpc: "https://eth.didlab.org",
        nativeCurrency: { name: "Trust", symbol: "TT", decimals: 18 }
      }
    };

    const el = (id) => document.getElementById(id);
    const networkSel = el("network");
    const rpcInput = el("rpc");
    const tokenInput = el("tokenAddr");
    const acctEl = el("acct");
    const netEl = el("net");
    const metaEl = el("meta");
    const balEl = el("bal");
    const txlog = el("txlog");

    const DEFAULTS = {
      network: "trust",
      rpc: NETWORKS.trust.rpc,
      token: "",
      tokenName: "CampusCredit",
      tokenSymbol: "CAMP"
    };

    let chain;
    let token;
    let decimals = 18;
    let symbol = DEFAULTS.tokenSymbol;
    let name = DEFAULTS.tokenName;
    let walletClient;
    let publicClient;
    let account;

    const saved = JSON.parse(localStorage.getItem("didlab-ui") || "{}");
    networkSel.value = saved.network || DEFAULTS.network;
    rpcInput.value = saved.rpc || DEFAULTS.rpc;
    tokenInput.value = saved.token || DEFAULTS.token;

    function save() {
      localStorage.setItem("didlab-ui", JSON.stringify({
        network: networkSel.value,
        rpc: rpcInput.value,
        token: tokenInput.value
      }));
    }

    function currentChain() {
      const cfg = NETWORKS[networkSel.value] || NETWORKS.trust;
      const rpcUrl = rpcInput.value.trim() || cfg.rpc;
      if (!rpcUrl) throw new Error("Enter RPC endpoint");
      return {
        id: cfg.id,
        name: cfg.name,
        nativeCurrency: cfg.nativeCurrency,
        rpcUrls: { default: { http: [rpcUrl] } }
      };
    }

    function hexChainId(id) {
      return "0x" + id.toString(16);
    }

    async function ensureMetamask() {
      if (!window.ethereum) throw new Error("MetaMask not found");
    }

    async function addOrSwitchNetwork() {
      const cfg = NETWORKS[networkSel.value] || NETWORKS.trust;
      const rpcUrl = rpcInput.value.trim() || cfg.rpc;
      if (!rpcUrl) throw new Error("Enter RPC endpoint");
      const params = [{
        chainId: hexChainId(cfg.id),
        chainName: cfg.name,
        rpcUrls: [rpcUrl],
        nativeCurrency: cfg.nativeCurrency
      }];
      try {
        await window.ethereum.request({
          method: "wallet_switchEthereumChain",
          params: [{ chainId: params[0].chainId }]
        });
      } catch (err) {
        await window.ethereum.request({
          method: "wallet_addEthereumChain",
          params
        });
      }
    }

    async function connect() {
      await ensureMetamask();
      chain = currentChain();
      walletClient = createWalletClient({ chain, transport: custom(window.ethereum) });
      publicClient = createPublicClient({ chain, transport: custom(window.ethereum) });
      await addOrSwitchNetwork();
      const addrs = await window.ethereum.request({ method: "eth_requestAccounts" });
      account = getAddress(addrs[0]);
      acctEl.textContent = account;
      netEl.textContent = `${chain.name} (#${chain.id}, ${chain.nativeCurrency.symbol})`;
      logOk("Connected. Network ready.");
    }

    async function loadToken() {
      token = getAddress(tokenInput.value.trim());
      save();
      name = await publicClient.readContract({ address: token, abi: ERC20_ABI, functionName: "name" });
      symbol = await publicClient.readContract({ address: token, abi: ERC20_ABI, functionName: "symbol" });
      decimals = Number(await publicClient.readContract({ address: token, abi: ERC20_ABI, functionName: "decimals" }));
      metaEl.textContent = `${name} (${symbol}), ${decimals}d, ${token}`;
      logOk(`Loaded token ${symbol}`);
      publicClient.watchContractEvent({
        address: token,
        abi: ERC20_ABI,
        eventName: "Transfer",
        onLogs: (logs) => {
          for (const l of logs) {
            if (l.args.from?.toLowerCase() === account.toLowerCase() || l.args.to?.toLowerCase() === account.toLowerCase()) {
              refresh();
              break;
            }
          }
        }
      });
      await refresh();
    }

    async function refresh() {
      if (!token || !account) return;
      const bal = await publicClient.readContract({
        address: token,
        abi: ERC20_ABI,
        functionName: "balanceOf",
        args: [account]
      });
      balEl.textContent = `${formatUnits(bal, decimals)} ${symbol}`;
    }

    async function send() {
      const to = getAddress(el("to").value.trim());
      const amtStr = el("amt").value.trim();
      if (!amtStr) throw new Error("Enter amount");
      const amount = parseUnits(amtStr, decimals);
      const hash = await walletClient.writeContract({
        address: token,
        abi: ERC20_ABI,
        functionName: "transfer",
        args: [to, amount],
        maxPriorityFeePerGas: 2000000000n,
        maxFeePerGas: 21000000000n,
        account
      });
      logWarn(`Submitted: ${hash}`);
      const rcpt = await publicClient.waitForTransactionReceipt({ hash });
      logOk(`Mined in block ${rcpt.blockNumber} (gas ${rcpt.gasUsed})`);
    }

    async function watchAsset() {
      if (!token || !symbol) return;
      await window.ethereum.request({
        method: "wallet_watchAsset",
        params: {
          type: "ERC20",
          options: { address: token, symbol, decimals }
        }
      });
      logOk("Token added to MetaMask (or already present).");
    }

    function logOk(message) {
      txlog.innerHTML = `<div class="ok">${escapeHtml(message)}</div>` + txlog.innerHTML;
    }

    function logWarn(message) {
      txlog.innerHTML = `<div class="warn">${escapeHtml(message)}</div>` + txlog.innerHTML;
    }

    function logErr(message) {
      txlog.innerHTML = `<div class="err">${escapeHtml(message)}</div>` + txlog.innerHTML;
    }

    function escapeHtml(str) {
      return str.replace(/[&<>"]/g, (c) => ({
        "&": "&amp;",
        "<": "&lt;",
        ">": "&gt;",
        '"': "&quot;"
      }[c]));
    }

    el("btnConnect").onclick = async () => {
      try {
        await connect();
      } catch (err) {
        logErr(err.message || err);
      }
    };

    el("btnLoad").onclick = async () => {
      try {
        await loadToken();
      } catch (err) {
        logErr(err.message || err);
      }
    };

    el("btnRefresh").onclick = async () => {
      try {
        await refresh();
      } catch (err) {
        logErr(err.message || err);
      }
    };

    el("btnSend").onclick = async () => {
      try {
        await send();
      } catch (err) {
        logErr(err.shortMessage || err.message || err);
      }
    };

    el("btnWatch").onclick = async () => {
      try {
        await watchAsset();
      } catch (err) {
        logErr(err.message || err);
      }
    };

    (async () => {
      if (tokenInput.value) metaEl.textContent = `Ready to load ${tokenInput.value}`;
    })();
  </script>
</body>
</html>
